# 資料庫設計經驗教訓

## 背景

在BlockMeet專案的早期開發階段，我們採用了一些不標準的資料庫設計模式，包括：

1. 在用戶資料表中使用JSON欄位（profile_data）存儲複雜的結構化資料
2. 用戶ID採用特殊格式而非標準UUID
3. 缺乏適當的資料正規化

這些決策導致了多種問題，從而促使我們進行了重構。本文檔記錄我們的經驗和教訓。

## 主要問題

### 1. JSON資料存儲

**問題**：我們使用`profile_data` JSON欄位存儲用戶頭像、統計數據等結構化資訊，導致：
- 查詢複雜（需要JSON解析）
- 無法建立欄位索引
- 數據一致性難以保證
- 數據驗證困難
- 佔用額外空間
- 數據變更困難

**解決方案**：將JSON中的數據遷移到專用欄位和表中：
- 頭像URL → avatar_url欄位
- 統計數據 → user_statistics表

### 2. 特殊ID格式

**問題**：我們在系統中混用了不同格式的用戶ID，包括：
- 具有特殊前綴的ID ("user_XXX")
- 標準UUID

導致系統需要額外的ID轉換邏輯，增加了複雜性和出錯機會。

**混合ID的具體問題**：
- 系統需要在多處檢查和轉換ID格式
- 登入、資料存取和API請求中需要特殊處理
- 難以追蹤身份認證問題來源
- 前端和後端處理邏輯不一致
- 資料庫查詢時需要考慮多種ID格式

**解決方案**：
- 統一採用標準UUID格式
- 移除所有ID格式轉換代碼
- 資料庫中確保ID欄位保持一致
- 在種子數據中為測試帳號分配固定UUID

**遷移策略**：
1. 更新種子文件，為特殊ID帳號（如`user_123`）分配固定UUID
2. 移除所有檢查ID格式和轉換邏輯的代碼
3. 更新API和前端組件，直接使用UUID格式
4. 確保所有數據庫操作使用UUID作為唯一標識

### 3. 缺乏資料正規化

**問題**：將不同類型的資料混合在少數幾個表中，導致：
- 表結構臃腫
- 查詢效率低下
- 難以維護和擴展

**解決方案**：將用戶相關資料拆分為多個專用表：
- users：核心用戶資訊
- user_profiles：用戶個人資料
- user_settings：用戶偏好設置
- user_statistics：統計數據

## 經驗教訓

1. **避免在關係型資料庫中使用JSON存儲結構化資料**
   - JSON適用於存儲偶爾需要的半結構化數據
   - 經常查詢或需要索引的數據應使用專用欄位

2. **始終使用標準化的ID格式**
   - 避免自定義ID格式和轉換邏輯
   - UUID提供了全球唯一性和良好的分散性
   - 避免包含業務邏輯或語義信息的ID
   - 一旦選定ID格式，應在整個系統保持一致

3. **避免特殊情況處理**
   - 特例處理代碼（如特殊ID格式）會導致系統脆弱
   - 即使是對少數測試帳號的特殊處理也會引入大量複雜性
   - 即使短期內看似方便，長期會增加維護成本和出錯風險

4. **遵循資料庫正規化原則**
   - 每個表應有明確單一的責任
   - 避免數據冗餘和異常
   - 合理使用外鍵關係

5. **保持代碼和資料庫設計一致**
   - 數據庫架構變更應同步更新相關代碼
   - 不要在應用層實現應該在數據庫層處理的邏輯

6. **從一開始就做好系統基礎設計**
   - 早期的設計決策影響整個系統生命週期
   - 修復基礎設計問題的成本隨時間快速增加
   - 投入時間在初期的架構設計上是值得的

## ID標準化實施細節

在ID標準化過程中，我們學到了以下關鍵經驗：

1. **原子化的遷移步驟**：將遷移分為小步驟（種子數據、服務層、API層、前端），逐一測試和驗證

2. **向後兼容性考慮**：為特殊帳號分配固定UUID，確保系統功能不受影響

3. **簡化身份認證流程**：
   - 移除所有ID格式檢查和轉換代碼
   - 直接使用標準UUID進行數據存儲和API請求
   - 簡化localStorage中的用戶數據管理

4. **徹底清除舊代碼**：
   - 移除所有舊格式的註釋和參考
   - 更新所有測試數據和模擬數據
   - 清理遺留的向後兼容代碼

5. **詳細記錄遷移過程**：
   - 創建完整的遷移文檔
   - 記錄問題根源和解決方案
   - 分享學到的經驗教訓

## 執行遷移步驟

我們執行了以下步驟進行遷移：

1. 創建新的資料表結構
2. 添加新欄位（如avatar_url）
3. 從JSON中提取數據並遷移到適當的表和欄位
4. 更新應用程式代碼以使用新的資料結構
5. 移除舊的JSON欄位和特殊ID處理邏輯
6. 測試所有功能以確保正常運作

## UUID vs 自定義ID格式的比較

| 方面 | 自定義ID格式 | UUID |
|------|------------|------|
| **全局唯一性** | 需要中央協調 | 內建，無需中央協調 |
| **生成方式** | 通常基於序列或業務規則 | 基於隨機數據或時間戳 |
| **信息暴露** | 可能暴露業務信息或創建順序 | 不暴露任何業務信息 |
| **系統複雜性** | 需要額外的格式處理邏輯 | 標準化，無需特殊處理 |
| **可擴展性** | 可能難以跨系統整合 | 標準格式，易於跨系統使用 |
| **數據庫支持** | 通常需要字符串類型 | 多數數據庫有專門的UUID類型 |

## 結論

這次重構顯著提高了系統的穩定性、可維護性和擴展性。雖然過程耗時，但帶來的長期好處遠超短期成本。特別是：

- 系統更加可靠，不再有ID轉換的問題
- 數據結構更清晰，便於新團隊成員理解
- 查詢效率提升，特別是針對特定數據類型的查詢
- 數據完整性和一致性得到更好保障
- 身份認證流程簡化，減少了出錯機會

未來的專案應從一開始就採用這些最佳實踐，避免後期的大規模重構。特別是，應該：

- 使用標準UUID作為唯一標識符
- 避免混合不同的ID格式
- 遵循資料庫正規化原則
- 避免在關係型資料庫中過度使用JSON

這些經驗教訓對於構建更穩健、可維護的系統至關重要。 